package com.foo.common.base.dao;

import java.io.Serializable;
import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import com.foo.common.base.pojo.FooGenericSearch;
import com.foo.common.base.pojo.FooGenericTransactionModel;
import com.googlecode.genericdao.search.ISearch;
import com.googlecode.genericdao.search.SearchResult;

/**
 * @author Steve
 * 
 * @param <T>
 * @param <ID>
 */
@Repository
public class FooGenericDaoImpl<T, ID extends Serializable> implements
		FooGenericDao<T, ID> {

	private SessionFactory sessionFactory;

	@Autowired
	/**
	 * Automatic autowire the sessionFactory here.
	 */
	public void setSessionFactory(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}

	protected SessionFactory getSessionFactory() {
		return sessionFactory;
	}

	/**
	 * Get the current Hibernate session
	 */
	@Override
	public Session getSession() {
		return sessionFactory.getCurrentSession();
	}

	/**
	 * <p>
	 * Persist the given transient instance and add it to the datastore, first
	 * assigning a generated identifier. (Or using the current value of the
	 * identifier property if the assigned generator is used.) This operation
	 * cascades to associated instances if the association is mapped with
	 * cascade="save-update".
	 * 
	 * <p>
	 * This is different from <code>persist()</code> in that it does guarantee
	 * that the object will be assigned an identifier immediately. With
	 * <code>save()</code> a call is made to the datastore immediately if the id
	 * is generated by the datastore so that the id can be determined. With
	 * <code>persist</code> this call may not occur until flush time.
	 * 
	 * @return The id of the newly saved entity.
	 */
	protected Serializable _save(Object entity) {
		return getSession().save(entity);
	}

	/**
	 * Persist the given transient instances and add them to the datastore,
	 * first assigning a generated identifier. (Or using the current value of
	 * the identifier property if the assigned generator is used.) This
	 * operation cascades to associated instances if the association is mapped
	 * with cascade="save-update".
	 */
	protected void _save(Object... entities) {
		for (Object entity : entities) {
			_save(entity);
		}
	}

	/**
	 * <p>
	 * Calls Hibernate's <code>saveOrUpdate()</code>, which behaves as follows:
	 * 
	 * <p>
	 * Either <code>save()</code> or <code>update()</code> based on the
	 * following rules
	 * <ul>
	 * <li>if the object is already persistent in this session, do nothing
	 * <li>
	 * if another object associated with the session has the same identifier,
	 * throw an exception
	 * <li>if the object has no identifier property, save() it
	 * <li>if the object's identifier has the value assigned to a newly
	 * instantiated object, save() it
	 * <li>if the object is versioned (by a &lt;version&gt; or
	 * &lt;timestamp&gt;), and the version property value is the same value
	 * assigned to a newly instantiated object, save() it
	 * <li>otherwise update() the object
	 * </ul>
	 */
	protected void _saveOrUpdate(Object entity) {
		getSession().saveOrUpdate(entity);
	}

	/**
	 * <p>
	 * If an entity already exists in the datastore with the same id, call
	 * _update and return false (not new). If no such entity exists in the
	 * datastore, call _save() and return true (new)
	 * 
	 * @return <code>true</code> if _save(); <code>false</code> if _update().
	 */
	protected boolean _saveOrUpdateIsNew(Object entity) {
		if (entity == null)
			throw new IllegalArgumentException(
					"attempt to saveOrUpdate with null entity");

		getSession().saveOrUpdate(entity);
		return true;
		// Serializable id = getMetadataUtil().getId(entity);
		// Serializable id = getSession().getIdentifier(entity);
		// if (getSession().contains(entity))
		// return false;
		//
		// if (id == null || (new Long(0)).equals(id) || !_exists(entity)) {
		// _save(entity);
		// return true;
		// } else {
		// _update(entity);
		// return false;
		// }
	}

	@Override
	public T find(ID id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public T[] find(ID... ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean save(T entity) {
		getSession().save(entity);
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean[] save(T... entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean remove(T entity) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void remove(T... entities) {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean removeById(ID id) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void removeByIds(ID... ids) {
		// TODO Auto-generated method stub

	}

	@Override
	public List<T> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <RT> RT searchUnique(ISearch search) {

		Query myQuery = getSession().createQuery("select * from ");
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int count(ISearch search) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isAttached(T entity) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void refresh(T... entities) {
		// TODO Auto-generated method stub

	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub

	}

	@Override
	public void remove(List<T> entities) {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean[] save(List<T> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <RT> SearchResult<RT> searchAndCount(
			FooGenericSearch fooGenericSearch) {

		Query query = getSession().createQuery(fooGenericSearch.getQueryHql());
		query.setFirstResult(fooGenericSearch.getFirstResult());
		query.setMaxResults(fooGenericSearch.getMaxResults());
		SearchResult<RT> myResult = new SearchResult<RT>();
		myResult.setResult(query.list());

		query = getSession().createQuery(fooGenericSearch.getCountHql());
		myResult.setTotalCount(((Number) query.uniqueResult()).intValue());
		return myResult;
	}

}
